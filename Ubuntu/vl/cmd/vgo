#!/bin/bash
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
source "${SCRIPT_DIR}/vutil_vars"

function Help {
    echo "Usage:"
    echo "p <project>"
    echo "    Go to the root folder of this project."
    echo "t <project>"
    echo "    Go to the \"Test/Linux\" folder of this project."
    echo "s <project>"
    echo "    Go to the \"Source\" folder of this project"
    echo "u [<project>]"
    echo "    Get the latest code of this project's master branch, or all projects if it is not specified."
    echo "uall [<project>]"
    echo "    Get the latest code of this project's all branch, or all projects if it is not specified."
    echo "vmake [<project>]"
    echo "    Call vmake on this project's all available folders, or all projects if it is not specified."
    echo "vbuild [<project>]"
    echo "    Call vbuild on this project's all available folders, or all projects if it is not specified."
}

function Go {
    local VPROJ="${VROOT}/$2"
    if ! [ -d $VPROJ ]; then
        echo "Folder \"${VPROJ}\" does not exist."
        return 1
    fi

    pushd $VPROJ > /dev/null
    local GITHEAD="$(git symbolic-ref HEAD 2>/dev/null)"
    if [ "${GITHEAD}" == "" ]; then
        echo "\"${VPROJ}\" is not a valid git repo."
        popd > /dev/null
        return 1
    fi

    local VPATH="${VPROJ}/$1"
    if ! [ -d $VPATH ]; then
        echo Fail "Folder \"${VPATH}\" does not exist."
        popd > /dev/null
        return 1
    fi

    popd > /dev/null
    cd $VPATH
}

function UpdateMaster {
    if [ "$1" == "" ]; then
        for i in "${GITHUB_REPOS[@]}"; do
            UpdateMaster $i
        done
    else
        pushd . > /dev/null
        printf "${VC_LIGHTGREEN}Pulling from ${VC_LIGHTBLUE}$1${VC_DEFAULT}\n"
        Go "" $1
        if [ "$PWD" == "${VROOT}/$1" ]; then
            git pull --all
        fi
        git remote prune origin
        git checkout master
        git pull origin master

        popd > /dev/null
    fi
}

function Update {
    if [ "$1" == "" ]; then
        for i in "${GITHUB_REPOS[@]}"; do
            Update $i
        done
    else
        pushd . > /dev/null
        printf "${VC_LIGHTGREEN}Pulling from ${VC_LIGHTBLUE}$1${VC_DEFAULT}\n"
        Go "" $1
        if [ "$PWD" == "${VROOT}/$1" ]; then
            git pull --all
        fi
        git remote prune origin

        local GITHEAD="$(git symbolic-ref HEAD 2>/dev/null)"
        local CURRENT_BRANCH="${GITHEAD##refs/heads/}"
        local BRANCHES=($(git branch -r | grep -v '.*->.*' | sed -r -e 's/^..origin\///g'))
        for BRANCH in "${BRANCHES[@]}"; do
            printf "${VC_LIGHTGREEN}Updating branch: ${VC_LIGHTCYAN}${BRANCH}${VC_DEFAULT}\n"
            git checkout $BRANCH
            git pull origin $BRANCH
        done
        git checkout $CURRENT_BRANCH

        popd > /dev/null
    fi
}

function VMake {
    if [ "$1" == "" ]; then
        for i in "${GITHUB_REPOS_CPP[@]}"; do
            VMake $i
        done
    else
        pushd . > /dev/null
        printf "${VC_LIGHTGREEN}Running vmake in ${VC_LIGHTBLUE}$1${VC_DEFAULT}\n"
        Go "" $1
        local GITHEAD="$(git symbolic-ref HEAD 2>/dev/null)"
        local CURRENT_BRANCH="${GITHEAD##refs/heads/}"

        local VMAKE_FOLDERS=()
        while IFS= read -r -d '' VMAKE_FILE; do
            VMAKE_FOLDERS+=("$(dirname "${VMAKE_FILE}")")
        done < <(find . -type f -name vmake -print0 2>/dev/null)

        IFS=$'\n' VMAKE_FOLDERS=($(printf '%s\n' "${VMAKE_FOLDERS[@]}" | sort -u))
        unset IFS

        local DIRS_WITH_OUTPUT=()
        for VDIR in "${VMAKE_FOLDERS[@]}"; do
            if [ "${VDIR}" == "" ]; then
                continue
            fi

            pushd "${VDIR}" > /dev/null
            printf "${VC_LIGHTGREEN}Running vmake in ${VC_LIGHTCYAN}${VDIR}${VC_DEFAULT}\n"

            local OUT
            OUT="$(vmake --make 2>&1)"
            local RC=$?
            if [ "${OUT}" != "" ] || [ ${RC} -ne 0 ]; then
                DIRS_WITH_OUTPUT+=("${VDIR}")
                if [ "${OUT}" != "" ]; then
                    printf "%s\n" "${OUT}"
                fi
                if [ ${RC} -ne 0 ] && [ "${OUT}" == "" ]; then
                    printf "${VC_LIGHTRED}vmake exited with code ${RC}${VC_DEFAULT}\n"
                fi
            fi

            popd > /dev/null
        done

        if [ ${#DIRS_WITH_OUTPUT[@]} -ne 0 ]; then
            printf "${VC_LIGHTRED}vmake produced output in the following folders:${VC_DEFAULT}\n"
            for VDIR in "${DIRS_WITH_OUTPUT[@]}"; do
                printf "  ${VC_LIGHTCYAN}%s${VC_DEFAULT}\n" "${VDIR}"
            done
            popd > /dev/null
            return 1
        fi

        local STATUS="$(git status --porcelain)"
        if [ "${STATUS}" != "" ]; then
            git add .
            git commit -am "Update makefiles"
            git push origin $CURRENT_BRANCH
        fi

        popd > /dev/null
    fi
}

function VBuild {
    if [ "$1" == "" ]; then
        for i in "${GITHUB_REPOS_CPP[@]}"; do
            Update $i
        done
    else
        pushd . > /dev/null
        printf "${VC_LIGHTGREEN}Running vbuild in ${VC_LIGHTBLUE}$1${VC_DEFAULT}\n"
        Go "" $1

        # create folder $VROOT/.vbuild if not exists
        local VBUILD_DIR="${VROOT}/.vbuild"
        mkdir -p "${VBUILD_DIR}"

        # prepare to write what is required to the log file $VROOT/.vbuild/$1
        local LOG_FILE="${VBUILD_DIR}/$1"
        local LOG_WRITTEN=0

        local VMAKE_FOLDERS=()
        while IFS= read -r -d '' VMAKE_FILE; do
            VMAKE_FOLDERS+=("$(dirname "${VMAKE_FILE}")")
        done < <(find . -type f -name vmake -print0 2>/dev/null)

        IFS=$'\n' VMAKE_FOLDERS=($(printf '%s\n' "${VMAKE_FOLDERS[@]}" | sort -u))
        unset IFS

        for VDIR in "${VMAKE_FOLDERS[@]}"; do
            if [ "${VDIR}" == "" ]; then
                continue
            fi

            pushd "${VDIR}" > /dev/null
            printf "${VC_LIGHTGREEN}Running vbuild in ${VC_LIGHTCYAN}${VDIR}${VC_DEFAULT}\n"

            # run vbuild --clean in a subshell, e.g. (vbuild --clean)
            local CLEAN_OUT
            CLEAN_OUT="$( (vbuild --clean) 2>&1 )"
            local CLEAN_RC=$?
            if [ ${CLEAN_RC} -ne 0 ]; then
                {
                    printf "Clean failed\n"
                    printf "Project: %s\n" "$1"
                    printf "Folder: %s\n" "${VDIR}"
                    printf "%s\n" "${CLEAN_OUT}"
                    printf "\n"
                } >> "${LOG_FILE}"
                LOG_WRITTEN=1
            fi

            # run vbuild --build in a subshell, remember the output, if it contains anything like "warning:" or "error:", log the complete output, the first line is "Build failed"
            local BUILD_OUT
            BUILD_OUT="$( (vbuild --build) 2>&1 )"
            local BUILD_RC=$?
            if printf "%s" "${BUILD_OUT}" | grep -E -i -q "(^|[^A-Za-z])(warning:|error:)"; then
                {
                    printf "Build failed\n"
                    printf "Project: %s\n" "$1"
                    printf "Folder: %s\n" "${VDIR}"
                    printf "%s\n" "${BUILD_OUT}"
                    printf "\n"
                } >> "${LOG_FILE}"
                LOG_WRITTEN=1
            elif [ ${BUILD_RC} -ne 0 ]; then
                {
                    printf "Build failed\n"
                    printf "Project: %s\n" "$1"
                    printf "Folder: %s\n" "${VDIR}"
                    printf "%s\n" "${BUILD_OUT}"
                    printf "\n"
                } >> "${LOG_FILE}"
                LOG_WRITTEN=1
            fi

            # check if ./Bin/UnitTest exists, skip if not
            if [ -x "./Bin/UnitTest" ]; then
                # run ./Bin/UnitTest in a subshell, remember the output
                local UT_OUT
                UT_OUT="$( (./Bin/UnitTest) 2>&1 )"
                local UT_RC=$?

                # if it crashed (non-zero), log the complete output, the first line is "Unit Test Failed"
                if [ ${UT_RC} -ne 0 ]; then
                    {
                        printf "Unit Test Failed\n"
                        printf "Project: %s\n" "$1"
                        printf "Folder: %s\n" "${VDIR}"
                        printf "ExitCode: %s\n" "${UT_RC}"
                        printf "%s\n" "${UT_OUT}"
                        printf "\n"
                    } >> "${LOG_FILE}"
                    LOG_WRITTEN=1
                fi
            fi

            # print git status --porcelain
            git status --porcelain

            popd > /dev/null
        done

        # if nothing needs to be written to the log, delete that log file, ignore deletion failure
        if [ ${LOG_WRITTEN} -eq 0 ]; then
            rm -f "${LOG_FILE}" 2>/dev/null || true
        fi

        popd > /dev/null
    fi
}

case $1 in
    --help)
    Help
    ;;

    p)
    Go "" $2
    ;;

    t)
    Go "Test/Linux" $2
    ;;

    s)
    Go "Source" $2
    ;;

    u)
    UpdateMaster $2
    ;;

    uall)
    Update $2
    ;;

    vmake)
    VMake $2
    ;;

    vbuild)
    VBuild $2
    ;;

    *)
    echo "Use --help for more information."
    ;;
esac
